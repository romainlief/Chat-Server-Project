\contentsline {section}{\numberline {1}Introduction}{2}{section.1}%
\contentsline {subsection}{\numberline {1.1}Présentation du projet et contexte}{2}{subsection.1.1}%
\contentsline {paragraph}{Dans le cadre de notre cours, nous avons réalisé un second projet qui, en s'appuyant sur les bases établies par le premier, vise à implémenter une messagerie en ligne utilisant un serveur implémenté en C. Cette messagerie permet donc la communication entre deux clients utilisant des ordinateurs différents, grâce à des sockets qui gèrent la connexion en ligne. Elle se compose de deux parties. La première est un programme `chat' s'occupant de, comme son nom l'indique, d'établir un système de chat entre le client et le serveur. La seconde est un script bash faisant office de `chat-auto' facilitant l'utilisation du programme chat. \\ Ce rapport décrit donc les choix d'implémentation, les difficultés rencontrées et les solutions mises en œuvre pour arriver à un résultat final satisfaisant nos attentes.}{2}{section*.2}%
\contentsline {subsection}{\numberline {1.2}Objectifs du projet}{2}{subsection.1.2}%
\contentsline {paragraph}{A l'image du précédent, l'objectif de ce second projet est de mettre en pratique les concepts vus en cours d'OS. Comme évoqué dans l'introduction, nous nous basons donc sur le premier projet. De ce fait, certains concepts comme les threads, la gestion des signaux et le bash sont une fois de plus utilisés. De nouveaux concepts s'ajoutent naturellement au premiers, à savoir les sockets et les mutexs. \\ Ce projet permet donc d'encore élargir notre éventail de compétences concernant les outils liés aux OS.}{2}{section*.3}%
\contentsline {section}{\numberline {2}Choix d’implémentation}{2}{section.2}%
\contentsline {subsection}{\numberline {2.1}Choix du langage}{2}{subsection.2.1}%
\contentsline {paragraph}{Le choix du langage de programmation entre le C et le C++ s'est une fois de plus offert à nous. Le C tombait sous le sens pour deux raisons bien distinctes. La première étant simplement le fait que le C est le langage utilisé durant les séances d'exercices et les cours théoriques. Ensuite, nous avons réalisé le premier projet en C. \\ Notre choix est donc une continuation logique de ces deux raisons.}{2}{section*.4}%
\contentsline {subsection}{\numberline {2.2}Choix de la méthode de gestion des clients}{2}{subsection.2.2}%
\contentsline {paragraph}{Concernant la gestion des clients nous avons fait le choix de les gérer à l'aide de threads. Autrement dit, à chaque client, un thread différent est assigné qui exécute la fonction `handle\_client'. Cette approche possède divers avantages décrits ci-dessous:}{2}{section*.5}%
\contentsline {paragraph}{Alternatives considérées:}{3}{section*.6}%
\contentsline {paragraph}{En définitive, l'utilisation des threads nous a permis de créer un serveur fluide, efficace et facile à maintenir, capable de gérer plusieurs clients simultanément.}{3}{section*.7}%
\contentsline {subsection}{\numberline {2.3}Gestion des accès concurrents}{3}{subsection.2.3}%
\contentsline {paragraph}{Afin d'assurer le fonctionnement correct de notre messagerie, la gestion des accès concurrents s'est révélée être un défi crucial à surmonter pour assurer l'intégrité des données partagées entre les différents threads et éviter leur corruption potentielle. Nous avons donc utilisé des mutexs pour synchroniser ces accès concurrents aux ressources partagées, comme la liste des clients connectés. Soulignons ci-dessous certains exemples de leur utilisation dans notre projet:}{3}{section*.8}%
\contentsline {subsection}{\numberline {2.4}Script bash}{3}{subsection.2.4}%
\contentsline {paragraph}{L'aspect technique du script bash se trouve dans la redirection des entrées et sorties du programme chat. Nous avons d'abord opté pour un usage de la commande `exec'. Or celle-ci remplace le processus courant par le celui exécuté par la commande. Ceci ne correspondant donc pas à nos besoins, nous avons simplement opté pour l'opérateur `$|$', appelé `pipe operator', qui permet une redirection de la sortie standard d'une commande vers l'entrée standard d'une autre commande. En utilisant la syntaxe suivante, ` \{ code \} $|$ ./chat \$utilisateur', cela nous permet, d'une part, de lancer le programme chat avec l'argument `utilisateur' et, d'autre part, de rediriger l'IO de ce programme vers le code entre crochets qui s'occupe d'ajouter le pseudo de l'utilisateur devant le message envoyé et le retourner complété. \\ En ce qui concerne la gestion des `ctrl-D', nous avons simplement opté pour deux boucles `while read -r'. En effet, si l'entrée standard est fermée, la boucle interne s'arrête et passe à la boucle externe qui redemande un pseudo de l'utilisateur.}{4}{section*.9}%
\contentsline {section}{\numberline {3}Difficultés Rencontrées et Solutions}{4}{section.3}%
\contentsline {subsection}{\numberline {3.1}Gestion des signaux dans client}{4}{subsection.3.1}%
\contentsline {paragraph}{La plus grosse difficulté que nous ayons rencontré est la gestion du `ctrl-D' en fonction des plateformes. En effet, le signal fonctionnait sans soucis sur Mac OS (dans le cas de notre code) mais nous nous sommes vite rendu compte que ce n'était pas le cas sur Linux. Autrement dit, sur Mac OS, le `ctrl-D' était interprété selon nos attentes et permettait d'interrompre l'exécution de la boucle de lecture et d'écriture. Or, sur Linux, suite à l'arrêt de la boucle, la lecture se poursuivait indéfiniment. Pour résoudre ce problème, nous avons donc utilisé la fonction `shutdown()' qui permet de bloquer toutes les tentatives de lecture du socket spécifié.}{4}{section*.10}%
\contentsline {subsection}{\numberline {3.2}Confusion dans les consignes}{4}{subsection.3.2}%
\contentsline {paragraph}{Les consignes du point 3.4 spécifient la tâche suivante: \\ "Afin de connaître le destinataire du message écrit par l'utilisatrice ou utilisateur, chaque message sur stdin doit être précédé du pseudonyme de son destinataire. Si ce pseudonyme contient des espaces, ces espaces sont remplacées par des tirets (p.ex., le pseudo \textless chat chat\textgreater s'écrira \textless chat-chat\textgreater )." \\ Après longue réflexion, cela nous est apparu comme étant impossible. En effet, pour lancer le programme chat, il est spécifié que le 1er argument doit être le pseudo et que les suivants sont obligatoirement `bot' et/ou `manuel'. De ce fait, il est impossible pour un utilisateur de faire usage d'un pseudo contenant un espace. Aussi, lors de l'écriture d'un message (une fois le programme lancé), il nous est demandé d'ignorer les messages ne contenant pas au minimum 2 mots. Mais alors, il n'y a plus aucun moyen de vérifier que les 2 entrées sont composées d'un seul et unique nom d'utilisateur ou bien d'un nom et d'un message ce qui ne permet plus de savoir si c'est une erreur ou un message valide. Ou encore, si nous oublions ce dernier point, lorsque le programme cherche a envoyer un message au premier mot entré, et qu'il ne le trouve pas, le serveur le signale, alors que nous cherchons peut être a contacter la combinaison des premiers mots du message. Dès lors nous avons conclu que ces lignes portaient à confusion et nous avons décidé d'en revenir a l'énoncé de base en laissant cette partie non-faite.}{4}{section*.11}%
\contentsline {section}{\numberline {4}Solutions Originales et Améliorations}{4}{section.4}%
\contentsline {subsection}{\numberline {4.1}Gestion des constante globales}{4}{subsection.4.1}%
\contentsline {paragraph}{Du fait de l'utilisation de C comme langage de programmation, l'orienté objet nous est inaccessible et nous n'avons donc pas accès aux constantes d'instances d'objets. Le premier réflexe est donc de mettre `const \textless nom de la constante\textgreater = `valeur'' lorsque celle-ci ne doit pas être modifiée et `\textless nom de la constante\textgreater = `valeur'' lorsqu'elle peut l'être. Cette méthode est tout à fait viable mais, malgré ça, nous avons utilisé une autre approche, à savoir mettre tout les constante globales non modifiable sous la forme `\#define \textless nom de la constante\textgreater \textless valeur\textgreater '. L'avantage de cette approche est l'économie d'espace mémoire. En effet, les variables globales déclarées de cette façon sont gérées par le préprocesseur qui remplace les occurences de cette variable dans le code avant la compilation et ne consomme pas d'espace en mémoire. Des problèmes de compatibilité entre types pourraient apparaître, certes, mais nous n'utilisons les constante globales que comme types simples comme `int' ou `str', tout en faisant attention à leur contexte d'utilisation, nous permettant ainsi d'éviter ces erreurs.}{5}{section*.12}%
\contentsline {subsection}{\numberline {4.2}File d'attente}{5}{subsection.4.2}%
\contentsline {paragraph}{Comme décrit dans les consignes, le serveur doit être muni d'une file d'attente pour les clients qui se connectent lorsque le serveur est plein. Pour cela nous avons utilisé une variable de type `atomic' pour calculer le nombre de personnes dans la file d'attente. Celle-ci nous permettent de compter les clients dans la boucle d'attente sans répétition. De plus, cela nous permet de facilement remplacer un client qui vient de se déconnecter par un client en attente.}{5}{section*.13}%
\contentsline {section}{\numberline {5}Conclusion}{5}{section.5}%
\contentsline {paragraph}{ Ce second et dernier projet de ce cours d'OS nous a permis d'approfondir nos connaissances concernant les threads, les signaux et le bash déjà utilisés dans le cadre du premier. A ces concepts s'ajoutent des nouveaux comme les mutexs et les sockets et leurs fonctions relatives comme `listen', `bind' et autres, également étudiés en cours. De plus, notre groupe étant resté le même pour la réalisation de chacun de ces deux projets, nous avons pu réitérer l'expérience de travail ensemble, de répartition des tâches et tout autre chose liée de près ou de loin aux travaux à plusieurs en nous basant sur notre modeste expérience lors du premier projet. Ceci nous a permis d'améliorer certains aspects, comme, notablement, la répartition de travail qui s'est faite de manière plus claire et plus efficace qu'à la première itération. \\ En combinant les travaux pratiques, les cours théoriques et les deux projets de ce cours de systèmes d'exploitation, chaque membre de notre groupe a pu progresser tant sur le plan personnel que professionnel. D'une part en apprenant de nombreux concepts liés aux OS, les appliquant et en les maitrisant et, d'autre part, en découvrant les divers aspects inhérents aux projets en groupes et en les intégrant pour mieux s'adapter dans le monde professionnel à l'avenir!}{5}{section*.14}%
