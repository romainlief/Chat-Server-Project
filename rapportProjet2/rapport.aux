\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Présentation du projet et contexte}{2}{subsection.1.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Dans le cadre de notre cours, nous avons réalisé un second projet qui, en s'appuyant sur les bases établies par le premier, vise à implémenter une messagerie en ligne utilisant un serveur implémenté en C. Cette messagerie permet donc la communication entre deux clients utilisant des ordinateurs différents, grâce à des sockets qui gèrent la connexion en ligne. Elle se compose de deux parties. La première est un programme `chat' s'occupant de, comme son nom l'indique, d'établir un système de chat entre le client et le serveur. La seconde est un script bash faisant office de `chat-auto' facilitant l'utilisation du programme chat. \\ Ce rapport décrit donc les choix d'implémentation, les difficultés rencontrées et les solutions mises en œuvre pour arriver à un résultat final satisfaisant nos attentes.}{2}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Objectifs du projet}{2}{subsection.1.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{A l'image du précédent, l'objectif de ce second projet est de mettre en pratique les concepts vus en cours d'OS. Comme évoqué dans l'introduction, nous nous basons donc sur le premier projet. De ce fait, certains concepts comme les threads, la gestion des signaux et le bash sont une fois de plus utilisés. De nouveaux concepts s'ajoutent naturellement au premiers, à savoir les sockets et les mutexs. \\ Ce projet permet donc d'encore élargir notre éventail de compétences concernant les outils liés aux OS.}{2}{section*.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}Choix d’implémentation}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Choix du langage}{2}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Le choix du langage de programmation entre le C et le C++ s'est une fois de plus offert à nous. Le C tombait sous le sens pour deux raisons bien distinctes. La première étant simplement le fait que le C est le langage utilisé durant les séances d'exercices et les cours théoriques. Ensuite, nous avons réalisé le premier projet en C. \\ Notre choix est donc une continuation logique de ces deux raisons.}{2}{section*.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Choix de la méthode de gestion des clients}{2}{subsection.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Concernant la gestion des clients nous avons fait le choix de les gérer à l'aide de threads. Autrement dit, à chaque client, un thread différent est assigné qui exécute la fonction `handle\_client'. Cette approche possède divers avantages décrits ci-dessous:}{2}{section*.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Alternatives considérées:}{3}{section*.6}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{En définitive, l'utilisation des threads nous a permis de créer un serveur fluide, efficace et facile à maintenir, capable de gérer plusieurs clients simultanément.}{3}{section*.7}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Gestion des accès concurrents}{3}{subsection.2.3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Afin d'assurer le fonctionnement correct de notre messagerie, la gestion des accès concurrents s'est révélée être un défi crucial à surmonter pour assurer l'intégrité des données partagées entre les différents threads et éviter leur corruption potentielle. Nous avons donc utilisé des mutexs pour synchroniser ces accès concurrents aux ressources partagées, comme la liste des clients connectés. Soulignons ci-dessous certains exemples de leur utilisation dans notre projet:}{3}{section*.8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Script bash}{3}{subsection.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{L'aspect technique du script bash se trouve dans la redirection des entrées et sorties du programme chat. Nous avons d'abord opté un usage de la commande `exec'. Or celle-ci remplace le processus courant par le celui exécuté par la commande. Ceci ne correspondant donc pas à nos besoins, nous avons simplement opté pour l'opérateur `$|$', appelé `pipe operator', qui permet une redirection de la sortie standard d'une commande vers l'entrée standard d'une autre commande. En utilisant la syntaxe suivante, ` \{ code \} $|$ ./chat', cela nous permet de rediriger l'IO du programme chat vers le code entre crochets qui s'occupe d'ajouter le pseudo de l'utilisateur devant le message envoyé et le retourner complété. \\ En ce qui concerne la gestion des `ctrl-D', nous avons simplement opté pour deux boucles `while read -r'. En effet, si l'entrée standard est fermée, la boucle interne s'arrête et passe à la boucle externe qui redemande le pseudo de l'utilisateur.}{3}{section*.9}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3}Difficultés Rencontrées et Solutions}{4}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Gestion des signaux dans client}{4}{subsection.3.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{}{4}{section*.10}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}Solutions Originales et Améliorations}{4}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Gestion des constante globales}{4}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Du fait de l'utilisation de C comme langage de programmation, l'orienté objet nous est inaccessible et nous n'avons donc pas accès aux constantes d'instances d'objets. Le premier réflexe est donc de mettre `const \textless nom de la constante\textgreater = `valeur'' lorsque celle-ci ne doit pas être modifiée et `\textless nom de la constante\textgreater = `valeur'' lorsqu'elle peut l'être. Cette méthode est tout à fait viable mais, malgré ça, nous avons utilisé une autre approche, à savoir mettre tout les constante globales non modifiable sous la forme `\#define \textless nom de la constante\textgreater \textless valeur\textgreater '. L'avantage de cette approche est l'économie d'espace mémoire. En effet, les variables globales déclarées de cette façon sont gérées par le préprocesseur qui remplace les occurences de cette variable dans le code avant la compilation et ne consomme pas d'espace en mémoire. Des problèmes de compatibilité entre types pourraient apparaître, certes, mais nous n'utilisons les constante globales que comme types simples comme `int' ou `str', tout en faisant attention à leur contexte d'utilisation, nous permettant ainsi d'éviter ces erreurs.}{4}{section*.11}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Conclusion}{4}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{ Ce second et dernier projet de ce cours d'OS nous a permis d'approfondir nos connaissances concernant les threads, les signaux et le bash déjà utilisés dans le cadre du premier. A ces concepts s'ajoutent des nouveaux comme les mutexs et les sockets et leurs fonctions relatives comme `listen', `bind' et autres, également étudiés en cours. De plus, notre groupe étant resté le même pour la réalisation de chacun de ces deux projets, nous avons pu réitérer l'expérience de travail ensemble, de répartition des tâches et tout autre chose liée de près ou de loin aux travaux à plusieurs en nous basant sur notre modeste expérience lors du premier projet. Ceci nous a permis d'améliorer certains aspects, comme, notablement, la répartition de travail qui s'est faite de manière plus claire et plus efficace qu'à la première itération. \\ En combinant les travaux pratiques, les cours théoriques et les deux projets de ce cours de systèmes d'exploitation, chaque membre de notre groupe a pu progresser tant sur le plan personnel que professionnel. D'une part en apprenant de nombreux concepts liés aux OS, les appliquant et en les maitrisant et, d'autre part, en découvrant les divers aspects inhérents aux projets en groupes et en les intégrant pour mieux s'adapter dans le monde professionnel à l'avenir!}{4}{section*.12}\protected@file@percent }
\gdef \@abspage@last{5}
