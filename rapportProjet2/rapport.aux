\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Présentation du projet et contexte}{2}{subsection.1.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Dans le cadre de notre cours d'OS, nous avons réalisé un projet qui consiste à implémenter unz messagerie en ligne comprenant un serveur en C. Ce chat, permet la communication entre deux clients via des sockets en ligne et sur des ordinateurs différents. La messagerie est composé de deux parties, celle décrite ci-dessus et une autre écrite en bash, faisant office de chat-auto permettant la facilitation de l'utilisation du programme chat. Ce chat-auto est conçu pour simuler un client en automatisant les taches d'envoies de messages à l'interlocuteur.\\ Le projet se compose donc de deux parties : le programme de messagerie avec (client) et (server) et le script Bash (chat-auto).}{2}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Objectifs du projet}{2}{subsection.1.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{L'objectif de ce projet est de mettre en pratique les concepts vus en cours d'OS, notamment les sockets, les threads, la gestion des signaux, les mutexs,et le bash. Ce rapport décrit les choix d'implémentation, les difficultés rencontrées et les solutions mises en œuvre utilisée dans la construction de ce projet.}{2}{section*.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}Choix d’Implémentation}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Choix du langage}{2}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Dans le cadre de ce projet, nous avions le choix entre le C et le C++ comme langage de programmation. Nous avons fait le choix d'utiliser du C car c'est en C que nous avons vu la matère durant les séances de travaux pratiques et que la solution du premier projet a été faites en C. De plus, ayant fait le premier projet en C, il aurait été plus compliqué de faire le deuxième en C++ car il aurait fallu faire des recherches supplémentaires pour comprendre les différences entre les deux langages.}{2}{section*.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Choix de la méthode de gestion des clients}{2}{subsection.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Dans le cadre de ce projet, nous avons fait le choix de gérer les clients via des threads. Chaques clients est géré par un thread différent. Cela permet de gérer plusieurs clients en même temps et de ne pas bloquer le serveur lorsqu'un client envoie un message. C'est la fonction handle\_client qui est exécutée dans un thread différent pour chaque client. Nous avons choisi cette méthode car ceux-ci présentent plusieurs avantages :}{2}{section*.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Alternatives considérées :}{3}{section*.6}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{En définitive, l'utilisation des threads nous a permis de créer un serveur fluide, efficace et facile à maintenir, capable de gérer plusieurs clients simultanément sans être trop compliqué a gérer.}{3}{section*.7}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Gestion des accès concurrents}{3}{subsection.2.3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Pour que notre messagerie fonctionne correctement, la gestion des accès concurrents était un défi cruciale à réaliser pour assurer l'intégrité des données partagées entre les différents threads. Nous avons donc utilisé des mutex pour synchroniser l'accès aux ressources partagées, telles que la liste des clients connectés. Voici quelques exemples ou nous les avons utilisé :}{3}{section*.8}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Gestion des signaux}{3}{subsection.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{}{3}{section*.9}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3}Difficultés Rencontrées et Solutions}{3}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{}{3}{section*.10}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}Solutions Originales et Améliorations}{3}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Gestion des variables globales}{3}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Lors de la création du projet, étant donné que nous avons choisit le C comme langage de programmation, il était interdit d'utiliser de l'orienté objet et donc aucune variable dans les instanciations des objets. Le premier réflexe est donc de mettre "const \textless nom de la variable\textgreater = "valeur" lorsque celle-ci ne doit pas être modifié et "\textless nom de la variable\textgreater = "valeur" lorsqu'elle peut l'être. Nous avons alors fait le choix de mettre tout les variables globales non modifiable sous la forme "\#define \textless nom de la variable\textgreater \textless valeur\textgreater ". Cela permet d'avoir une lisibilité accrue, et économiser de l'espace mémoire. Des problèmes de compatibilité entre types pourraient apparaître, certes, mais nous n'utilisons les variables globales que comme types simples comme int ou str, tout en faisant attention à leur contexte d'utilisation, nous permettant ainsi d'éviter ces erreurs.}{4}{section*.11}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Conclusion}{4}{section.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Ce projet nous a permis de mettre en pratique et de se familiariser avec les concepts vus en cours d'OS, tels que les sockets, les signaux, les threads, et les mutex en C et de pratiquer le bash. Celui-ci, nous a appris à utiliser les outils de programmation en C comme sigaction, les fonctions relatives aux sockets telles que listen, bind,... . Ce projet nous a également permis de travailler à nouveau avec le même groupe que pour le premier projet, ce qui nous a permis de nous améliorer avec ce même groupe, impliquant une évolution dans la gestion et répartition du travail.}{4}{section*.12}\protected@file@percent }
\gdef \@abspage@last{5}
