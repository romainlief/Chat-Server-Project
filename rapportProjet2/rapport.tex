\documentclass[utf8]{article}

\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{amsmath}

\usepackage{fullpage}
\usepackage{hyperref}

% -----------------------------------------------------

\begin{document}

\begin{titlepage}
    \centering
    
    % Titre en haut de la page
    \vspace*{1cm}
    {\huge \bfseries Info F-201 : Projet d’OS \\
                    Rapport \par}
    
    % Espace vertical pour centrer le logo
    \vfill
    
    % Logo au milieu de la page
    \begin{figure}[h]
        \centering
        \includegraphics[scale=0.2]{logo.png}
    \end{figure}
    
    % Espace vertical pour descendre l'auteur et la date en bas
    \vfill
    
    % Auteur et date en bas de la page
    {\large Auteurs: Liefferinckx Romain, Rocca Manuel, Radu-Loghin Rares\\ 
            Matricules: 000591790, 000596086, 000590079 \\ 
            Section: INFO \par}
    {\large 2024, 4 Décembre \par}
\end{titlepage}

\newpage
\tableofcontents

\newpage


% -----------------------------------------------------

\section{Introduction}
\subsection{Présentation du projet et contexte}
\paragraph{Dans le cadre de notre cours d'OS, nous avons réalisé un projet qui consiste à implémenter unz messagerie en ligne comprenant un serveur en C.
Ce chat, permet la communication entre deux clients via des sockets en ligne et sur des ordinateurs différents. La messagerie est composé de deux parties, celle décrite ci-dessus et une autre écrite en bash,
faisant office de chat-auto permettant la facilitation de l'utilisation du programme chat. Ce chat-auto est conçu pour simuler un client en automatisant les taches d'envoies de messages à l'interlocuteur.\\
Le projet se compose donc de deux parties : le programme de messagerie avec (client) et (server) et le script Bash (chat-auto).}

\subsection{Objectifs du projet}
\paragraph{L'objectif de ce projet est de mettre en pratique les concepts vus en cours d'OS, notamment les sockets, les threads, la gestion
des signaux, les mutexs,et le bash. 
Ce rapport décrit les choix d'implémentation, les difficultés rencontrées et les solutions mises en œuvre utilisée dans la 
construction de ce projet.}

\section{Choix d’Implémentation}
\subsection{Choix du langage}
\paragraph{Dans le cadre de ce projet, nous avions le choix entre le C et le C++ comme langage de programmation.
Nous avons fait le choix d'utiliser du C car c'est en C que nous avons vu la matère durant les séances de travaux 
pratiques et que la solution du premier projet a été faites en C. 
De plus, ayant fait le premier projet en C, il aurait été plus compliqué de faire le deuxième en C++ car il aurait 
fallu faire des recherches supplémentaires pour comprendre les différences entre les deux langages.}

\subsection{Choix de la méthode de gestion des clients}
\paragraph{Dans le cadre de ce projet, nous avons fait le choix de gérer les clients via des threads. Chaques clients est géré par un thread différent.
Cela permet de gérer plusieurs clients en même temps et de ne pas bloquer le serveur lorsqu'un client envoie un message.
C'est la fonction handle\_client qui est exécutée dans un thread différent pour chaque client.
Nous avons choisi cette méthode car ceux-ci présentent plusieurs avantages :}
\begin{itemize}
    \item \textbf{Concurrence et Réactivité :} L'utilisation des threads permet de traiter les requêtes des clients de manière concurrente. Chaque client est géré indépendamment, ce qui améliore la réactivité du serveur. Si un client envoie seulement des messages de manière sporadique, cela n'affecte pas les autres clients.
    \item \textbf{Simplicité de l'implémentation :} Les threads sont relativement simples à utiliser (pthread).
    \item \textbf{Utilisation efficace des ressources :} Les threads partagent le même espace mémoire, ce qui permet une communication rapide et efficace entre eux. Les processus quant a eux n'auraient pas été une solution légère en mémoire pour gérer les clients.
    \item \textbf{Scalabilité :} Avec les threads, le serveur peut facilement gérer un grand nombre de clients simultanément. Chaque nouveau client est simplement un nouveau thread, ce qui permet une gestion dynamique des connexions.
\end{itemize}

\paragraph{Alternatives considérées :}
\begin{itemize}
    \item \textbf{Multiprocessing :} Utiliser des processus multiples pour chaque client aurait été une alternative. Cependant, cette méthode consomme plus de ressources car chaque processus a son propre espace mémoire. La communication entre processus est également plus complexe et moins efficace que la communication entre threads.
    \item \textbf{Multiplexing/Polling (select, poll, epoll) :} Une autre méthode aurait été d'utiliser des techniques de polling comme \texttt{select}, \texttt{poll} ou \texttt{epoll}. Bien que ces techniques soient certainement efficaces pour gérer de nombreuses connexions simultanées sans bloquer, elles sont plus complexes à implémenter et n'ayant pas beaucoup de temps pour ce projet ainsi que des connaissance restreinte sur le sujet, nous ne nous sommes pas risqué a les utiliser.
\end{itemize}

\paragraph{En définitive, l'utilisation des threads nous a permis de créer un serveur fluide, efficace et facile à maintenir, capable de gérer plusieurs clients simultanément sans être trop compliqué a gérer.}

\subsection{Gestion des accès concurrents}
\paragraph{}

\subsection{Gestion des signaux}
\paragraph{}

\section{Difficultés Rencontrées et Solutions}
\paragraph{}

\section{Solutions Originales et Améliorations}
\paragraph{}

\section{Conclusion}
\paragraph{Ce projet nous a permis de mettre en pratique et de se familiariser avec les concepts vus en cours d'OS,
tels que les sockets, les signaux, les threads, et les mutex en C et de pratiquer le bash.
Celui-ci, nous a appris à utiliser les outils de programmation en C comme sigaction, les fonctions relatives aux sockets telles que listen, bind,... .
Ce projet nous a également permis de travailler à nouveau avec le même groupe que pour le premier projet, ce qui nous a permis de nous 
améliorer avec ce même groupe, impliquant une évolution dans la gestion et répartition du travail.}



\end{document}